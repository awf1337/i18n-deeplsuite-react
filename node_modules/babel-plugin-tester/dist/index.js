"use strict";

var _assert = _interopRequireDefault(require("assert"));

var _path = _interopRequireDefault(require("path"));

var _fs = _interopRequireDefault(require("fs"));

var _os = require("os");

var _pathExists = _interopRequireDefault(require("path-exists"));

var _lodash = _interopRequireDefault(require("lodash.mergewith"));

var _invariant = _interopRequireDefault(require("invariant"));

var _stripIndent = _interopRequireDefault(require("strip-indent"));

var _commonTags = require("common-tags");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var noop = function noop() {};

module.exports = pluginTester;
var fullDefaultConfig = {
  babelOptions: {
    parserOpts: {},
    generatorOpts: {},
    babelrc: false
  }
};

function mergeCustomizer(objValue, srcValue) {
  if (Array.isArray(objValue)) {
    return objValue.concat(srcValue);
  }

  return undefined;
}

function pluginTester() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var _ref$babel = _ref.babel,
      babel = _ref$babel === void 0 ? require('@babel/core') : _ref$babel,
      _ref$plugin = _ref.plugin,
      plugin = _ref$plugin === void 0 ? requiredParam('plugin') : _ref$plugin,
      _ref$pluginName = _ref.pluginName,
      pluginName = _ref$pluginName === void 0 ? getPluginName(plugin, babel) : _ref$pluginName,
      _ref$title = _ref.title,
      describeBlockTitle = _ref$title === void 0 ? pluginName : _ref$title,
      pluginOptions = _ref.pluginOptions,
      tests = _ref.tests,
      fixtures = _ref.fixtures,
      _ref$fixtureOutputNam = _ref.fixtureOutputName,
      fixtureOutputName = _ref$fixtureOutputNam === void 0 ? 'output' : _ref$fixtureOutputNam,
      filename = _ref.filename,
      _ref$endOfLine = _ref.endOfLine,
      endOfLine = _ref$endOfLine === void 0 ? 'lf' : _ref$endOfLine,
      rest = _objectWithoutProperties(_ref, ["babel", "plugin", "pluginName", "title", "pluginOptions", "tests", "fixtures", "fixtureOutputName", "filename", "endOfLine"]);

  var testNumber = 1;

  if (fixtures) {
    testFixtures(_objectSpread({
      plugin,
      pluginName,
      pluginOptions,
      title: describeBlockTitle,
      fixtures,
      fixtureOutputName,
      filename,
      babel,
      endOfLine
    }, rest));
  }

  var testAsArray = toTestArray(tests);

  if (!testAsArray.length) {
    return;
  }

  var testerConfig = (0, _lodash.default)({}, fullDefaultConfig, rest, mergeCustomizer);
  describe(describeBlockTitle, function () {
    testAsArray.forEach(function (testConfig) {
      if (!testConfig) {
        return;
      }

      var _mergeWith = (0, _lodash.default)({}, testerConfig, toTestConfig(testConfig), mergeCustomizer),
          skip = _mergeWith.skip,
          only = _mergeWith.only,
          title = _mergeWith.title,
          code = _mergeWith.code,
          babelOptions = _mergeWith.babelOptions,
          output = _mergeWith.output,
          snapshot = _mergeWith.snapshot,
          error = _mergeWith.error,
          _mergeWith$setup = _mergeWith.setup,
          setup = _mergeWith$setup === void 0 ? noop : _mergeWith$setup,
          teardown = _mergeWith.teardown,
          _mergeWith$formatResu = _mergeWith.formatResult,
          formatResult = _mergeWith$formatResu === void 0 ? function (r) {
        return r;
      } : _mergeWith$formatResu;

      (0, _assert.default)(!skip && !only || skip !== only, 'Cannot enable both skip and only on a test');

      if (skip) {
        // eslint-disable-next-line jest/no-disabled-tests
        it.skip(title, testerWrapper);
      } else if (only) {
        // eslint-disable-next-line jest/no-focused-tests
        it.only(title, testerWrapper);
      } else {
        it(title, testerWrapper);
      }

      function testerWrapper() {
        return _testerWrapper.apply(this, arguments);
      } // eslint-disable-next-line complexity


      function _testerWrapper() {
        _testerWrapper = _asyncToGenerator(function* () {
          var teardowns = teardown ? [teardown] : [];
          var returnedTeardown;

          try {
            returnedTeardown = yield setup();
          } catch (e) {
            // eslint-disable-next-line no-console
            console.error('There was a problem during setup');
            throw e;
          }

          if (typeof returnedTeardown === 'function') {
            teardowns.push(returnedTeardown);
          }

          try {
            tester();
          } finally {
            try {
              yield Promise.all(teardowns.map(function (t) {
                return t();
              }));
            } catch (e) {
              // eslint-disable-next-line no-console
              console.error('There was a problem during teardown'); // eslint-disable-next-line no-unsafe-finally

              throw e;
            }
          }
        });
        return _testerWrapper.apply(this, arguments);
      }

      function tester() {
        (0, _invariant.default)(code, _commonTags.oneLine`
            A string or object with a \`code\` or
            \`fixture\` property must be provided
          `);
        (0, _invariant.default)(!babelOptions.babelrc || babelOptions.filename, 'babelrc set to true, but no filename specified in babelOptions');
        (0, _invariant.default)(!snapshot || !output, '`output` cannot be provided with `snapshot: true`');
        var result;
        var errored = false;

        try {
          result = formatResult(fixLineEndings(babel.transform(code, babelOptions).code, endOfLine, code));
        } catch (err) {
          if (error) {
            errored = true;
            result = err;
          } else {
            throw err;
          }
        }

        var expectedToThrowButDidNot = error && !errored;
        (0, _assert.default)(!expectedToThrowButDidNot, 'Expected to throw error, but it did not.');

        if (snapshot) {
          (0, _invariant.default)(result !== code, _commonTags.oneLine`
              Code was unmodified but attempted to take a snapshot.
              If the code should not be modified, set \`snapshot: false\`
            `);
          var separator = '\n\n      ↓ ↓ ↓ ↓ ↓ ↓\n\n';
          var formattedOutput = [code, separator, result].join('');
          expect(`\n${formattedOutput}\n`).toMatchSnapshot(title);
        } else if (error) {
          assertError(result, error);
        } else if (typeof output === 'string') {
          _assert.default.equal(result, output, 'Output is incorrect.');
        } else {
          _assert.default.equal(result.trim(), code.trim(), 'Expected output to not change, but it did');
        }
      }
    });
  });

  function toTestConfig(testConfig) {
    if (typeof testConfig === 'string') {
      testConfig = {
        code: testConfig
      };
    }

    var _testConfig = testConfig,
        title = _testConfig.title,
        fixture = _testConfig.fixture,
        _testConfig$code = _testConfig.code,
        code = _testConfig$code === void 0 ? getCode(filename, fixture) : _testConfig$code,
        _testConfig$fullTitle = _testConfig.fullTitle,
        fullTitle = _testConfig$fullTitle === void 0 ? title || `${testNumber++}. ${pluginName}` : _testConfig$fullTitle,
        _testConfig$output = _testConfig.output,
        output = _testConfig$output === void 0 ? getCode(filename, testConfig.outputFixture) || undefined : _testConfig$output,
        _testConfig$pluginOpt = _testConfig.pluginOptions,
        testOptions = _testConfig$pluginOpt === void 0 ? pluginOptions : _testConfig$pluginOpt;
    return (0, _lodash.default)({
      babelOptions: {
        filename: getPath(filename, fixture)
      }
    }, testConfig, _objectSpread({
      babelOptions: {
        plugins: [[plugin, testOptions]]
      },
      title: fullTitle,
      code: (0, _stripIndent.default)(code).trim()
    }, output ? {
      output: (0, _stripIndent.default)(output).trim()
    } : {}), mergeCustomizer);
  }
}

function fixLineEndings(code, endOfLine, input) {
  return code.replace(/\r?\n/g, getReplacement());

  function getReplacement() {
    switch (endOfLine) {
      case 'lf':
        {
          return '\n';
        }

      case 'crlf':
        {
          return '\r\n';
        }

      case 'auto':
        {
          return _os.EOL;
        }

      case 'preserve':
        {
          var match = input.match(/\r?\n/);

          if (match === null) {
            return _os.EOL;
          }

          return match[0];
        }

      default:
        {
          throw new Error("Invalid 'endOfLine' value");
        }
    }
  }
}

var createFixtureTests = function createFixtureTests(fixturesDir, options) {
  if (!_fs.default.statSync(fixturesDir).isDirectory()) return;

  var rootOptionsPath = _path.default.join(fixturesDir, 'options.json');

  var rootFixtureOptions = {};

  if (_pathExists.default.sync(rootOptionsPath)) {
    rootFixtureOptions = require(rootOptionsPath);
  }

  _fs.default.readdirSync(fixturesDir).forEach(function (caseName) {
    var fixtureDir = _path.default.join(fixturesDir, caseName);

    var optionsPath = _path.default.join(fixtureDir, 'options.json');

    var jsCodePath = _path.default.join(fixtureDir, 'code.js');

    var tsCodePath = _path.default.join(fixtureDir, 'code.ts');

    var jsxCodePath = _path.default.join(fixtureDir, 'code.jsx');

    var tsxCodePath = _path.default.join(fixtureDir, 'code.tsx');

    var blockTitle = caseName.split('-').join(' ');
    var codePath = _pathExists.default.sync(jsCodePath) && jsCodePath || _pathExists.default.sync(tsCodePath) && tsCodePath || _pathExists.default.sync(jsxCodePath) && jsxCodePath || _pathExists.default.sync(tsxCodePath) && tsxCodePath;
    var fixturePluginOptions = {};

    if (_pathExists.default.sync(optionsPath)) {
      fixturePluginOptions = require(optionsPath);
    }

    if (!codePath) {
      describe(blockTitle, function () {
        createFixtureTests(fixtureDir, _objectSpread({}, options, {
          pluginOptions: _objectSpread({}, rootFixtureOptions, {}, options.pluginOptions, {}, fixturePluginOptions)
        }));
      });
      return;
    }

    var ext = `.${codePath.split('.').pop()}`;
    it(blockTitle, function () {
      var plugin = options.plugin,
          pluginOptions = options.pluginOptions,
          fixtureOutputName = options.fixtureOutputName,
          babel = options.babel,
          endOfLine = options.endOfLine,
          _options$formatResult = options.formatResult,
          formatResult = _options$formatResult === void 0 ? function (r) {
        return r;
      } : _options$formatResult,
          rest = _objectWithoutProperties(options, ["plugin", "pluginOptions", "fixtureOutputName", "babel", "endOfLine", "formatResult"]);

      var babelRcPath = _path.default.join(fixtureDir, '.babelrc');

      var _mergeWith2 = (0, _lodash.default)({}, fullDefaultConfig, {
        babelOptions: {
          plugins: [[plugin, _objectSpread({}, rootFixtureOptions, {}, pluginOptions, {}, fixturePluginOptions)]],
          // if they have a babelrc, then we'll let them use that
          // otherwise, we'll just use our simple config
          babelrc: _pathExists.default.sync(babelRcPath)
        }
      }, rest, mergeCustomizer),
          babelOptions = _mergeWith2.babelOptions;

      var input = _fs.default.readFileSync(codePath).toString();

      var actual = formatResult(fixLineEndings(babel.transformSync(input, _objectSpread({}, babelOptions, {
        filename: codePath
      })).code, endOfLine, input));

      var outputPath = _path.default.join(fixtureDir, `${fixtureOutputName}${ext}`);

      if (!_fs.default.existsSync(outputPath)) {
        _fs.default.writeFileSync(outputPath, actual);

        return;
      }

      var output = _fs.default.readFileSync(outputPath, 'utf8');

      _assert.default.equal(actual.trim(), output.trim(), `actual output does not match ${fixtureOutputName}${ext}`);
    });
  });
};

function testFixtures(_ref2) {
  var describeBlockTitle = _ref2.title,
      fixtures = _ref2.fixtures,
      filename = _ref2.filename,
      rest = _objectWithoutProperties(_ref2, ["title", "fixtures", "filename"]);

  describe(`${describeBlockTitle} fixtures`, function () {
    var fixturesDir = getPath(filename, fixtures);
    createFixtureTests(fixturesDir, rest);
  });
}

function toTestArray(tests) {
  tests = tests || []; // null/0/false are ok, so no default param

  if (Array.isArray(tests)) {
    return tests;
  }

  return Object.keys(tests).reduce(function (testsArray, key) {
    var value = tests[key];

    if (typeof value === 'string') {
      value = {
        code: value
      };
    }

    testsArray.push(_objectSpread({
      title: key
    }, value));
    return testsArray;
  }, []);
}

function getCode(filename, fixture) {
  if (!fixture) {
    return '';
  }

  return _fs.default.readFileSync(getPath(filename, fixture), 'utf8');
}

function getPath(filename, basename) {
  if (!basename) {
    return undefined;
  }

  if (_path.default.isAbsolute(basename)) {
    return basename;
  }

  return _path.default.join(_path.default.dirname(filename), basename);
} // eslint-disable-next-line complexity


function assertError(result, error) {
  if (typeof error === 'function') {
    if (!(result instanceof error || error(result) === true)) {
      throw result;
    }
  } else if (typeof error === 'string') {
    (0, _assert.default)(result.message.includes(error), 'Error message is incorrect');
  } else if (error instanceof RegExp) {
    (0, _assert.default)(error.test(result.message), `Expected ${result.message} to match ${error}`);
  } else {
    (0, _invariant.default)(typeof error === 'boolean', 'The given `error` must be a function, string, boolean, or RegExp');
  }
}

function requiredParam(name) {
  throw new Error(`${name} is a required parameter.`);
}

function getPluginName(plugin, babel) {
  var name;

  try {
    name = plugin(babel).name;
  } catch (error) {
    // eslint-disable-next-line no-console
    console.error(_commonTags.oneLine`
        Attempting to infer the name of your plugin failed.
        Tried to invoke the plugin which threw the error.
      `);
    throw error;
  }

  (0, _invariant.default)(name, 'The `pluginName` must be inferable or provided.');
  return name;
}
/*
eslint
  complexity: "off"
*/